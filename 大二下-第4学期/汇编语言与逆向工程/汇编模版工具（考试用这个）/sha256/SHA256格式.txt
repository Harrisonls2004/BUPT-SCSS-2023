1.v7＞4可知要求长度大于4，((unsigned __int8)Str[i] <= 0x60u || (unsigned __int8)Str[i] > 0x7Au) && ((unsigned __int8)Str[i] <= 0x40u || (unsigned __int8)Str[i] > 0x5Au)可知为纯英文
2.进入sha256(Str1, Destination, 4)，sha256_init(v4)进行初始化，sha256_update(v4, a2, a3)进行填充512位，sha256_final(v4, (int)v5)进行迭代逻辑运算，return byte2str(a1, v5)返回。可知这是sha256，
3.最后比较，我们直接爆破密文45c6c64ffd31a750bcb2e150519f1963e5424bafd380637cff33075c25d35334
4.得到BUPT，大于4，加上任意小写字母。


	输入的flag要求长度大于等于5，且ascii码在大于等于65小于等于122。识别到main函数中调用的核心加密函数sub_401005。（2分）
	识别出哈希算法为SHA256，理由是：存在SHA256的初始特征值{0x67,0xe6,0x09,0x6a}等；sub_401500对输入数据填充至512的整数倍；sub_401760是SHA256进行逻辑运算的过程。（10分）
	Main函数中对哈希值的每字节进行了加1操作。加密后的flag哈希值存储在0x0428184处，将其每字节减1还原出flag的哈希值。（5分）
	爆破得到原始明文

# 解题思路：
# 1.初步判断flag长度大于等于5，并且每个字符的ascii码都在65~122之间
# 2.首先将我们的输入Source的前四位复制到Destination
# 3.接着执行sub_401005函数，这里面涉及到函数sub_40100A、sub_40100F、sub_401023、sub_40103C
# （1）sub_40100A函数
# 在该函数中对8个变量进行赋值，使用快捷键N将它们依次修改为A~H，使用快捷键H将它们的数值转化为十六进制，
# 由于计算机存储是小端模式，因此A~H真正的数值为：
# A=0x6A09E667,
# B=0xBB67AE85,
# C=0x3C6EF372,
# D=0xA54FF53A,
# E=0x510E527F,
# F=0x9B05688C,
# G=0x1F83D9AB,
# H=0x5BE0CD19,
# （2）sub_40100F函数
# 函数中出现了56、64以及模64这些数值的运算，实际上是是得数据填充后使得数据
# 的比特长度为512取模等于448，另外0x80其实是比特串“10000000”，与数据填充规则中
# 追加一个比特1，再填充0的填充规则相符合，因此该函数的作用是数据填充。
# （3）sub_401023函数
# 该函数对数据做了一些比特移位的操作，本质上将char类型的输入转化为整型
# （4）sub_40103C函数
# 该函数对变量a1~a8进行了64轮的计算操作，循环结束后，变量a1~a8与初始值相加，函数返回。

# sub_401005函数的for循环结束后，变量A~H链接并以十六进制的格式（"%08x%08x%08x%08X%08x%08x%08x%08x"）
# 写入到Buffer,注意第4个为08X,即大写输出。
# 因此该函数为SHA256函数。

# 总结：sub_401005()——>SHA256函数
# （1）sub_40100A         对A~h8个变量进行赋值
# （2）sub_40100F         数据填充
# （3）sub_401023         将char类型的输入转化为整型
# （4）sub_40103C         64轮步函数的运算规则
# 4.执行完sub_40100A函数后，对Str1的每个字符都+1
# 5.最后将Str1与"1f2e28649c4g:25:8bb:24c3D3EGF6GFg22dff:1dbd916df13239513g21e4663"
# 进行比较，若完全相同，则输出“Correct!”
# 6.我们在求解时，先将"1f2e28649c4g:25:8bb:24c3D3EGF6GFg22dff:1dbd916df13239513g21e4663"整体减去1，
# 得到“0e1d17538b3f91497aa913b2c2dfe5fef11cee90cac805ce02128402f10d3552”，这才是SHA256加密后的结果，
# 然后再进行SHA256暴力破解
# 7.求得的flag为“Seey”，但是因为flag的长度大于等于5位，后面随便加个ascii码在65~122之间的字符就好了
