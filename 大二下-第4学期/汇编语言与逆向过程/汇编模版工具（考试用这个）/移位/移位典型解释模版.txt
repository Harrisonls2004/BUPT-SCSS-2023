第一种
((Destination[i] & 3) << 6) ：按位与操作会保留最低 2 位，左移 6 位
 (4 * (Destination[i] & 0xC)) ：0xC 的二进制是 00001100，保留第 3~4 位，**4 * (...)**​：相当于左移 2 位（4 = 2²）
 ((Destination[i] & 0xF0) >> 4)：0xF0 的二进制是 11110000，保留高 4 位，右移 4 位

第二种
Destination[i] & 3 → 保留最低2位
16 * (Destination[i] & 0xC) →0xC 的二进制是 00001100，保留第 3~4 位，并左移4位
(Destination[i] & 0xF0) >> 2 → 保留最高4位并右移2位

第三种
((tmp & 3) << 6) ：按位与操作会保留最低 2 位，左移 6 位
((tmp & 0xC0) >> 6) ：0xC0 的二进制是 11000000，保留最高 2 位，右移 6 位
(tmp & 0x3C)：0x3C 的二进制是 00111100，保留中间 4 位
例如： abcdefgh，变成gh000000 | 000000ab | 00cdef00 = ghcdefab

第四种
(4 * (j & 3))：3 的二进制是 00000011，按位与操作会保留最低 2 位，​4 * (...)：相当于左移 2 位（4 = 2²）
 ((j & 0xC) >> 2) ：0xC 的二进制是 00001100，保留第 3~4 位，右移 2 位
 (j & 0xF0)：0xF0 的二进制是 11110000，保留高 4 位

第五种
Destination[i] = Destination[i] & 3：这是对 Destination[i] 的当前值和数字3（二进制0011）进行按位与(AND)操作
效果是保留最低两位（bit 0和bit1）
(16 * (Destination[i] & 0xC))：0xC 是二进制1100（十进制12）先获取 Destination[i] 的bit2和bit3（因为1100对应这两个位）然后乘以16（相当于左移4位）
((Destination[i] & 0xF0) >> 2)：0xF0 是二进制11110000（十进制240）获取 Destination[i] 的高4位（bit4-bit7）然后右移2位

