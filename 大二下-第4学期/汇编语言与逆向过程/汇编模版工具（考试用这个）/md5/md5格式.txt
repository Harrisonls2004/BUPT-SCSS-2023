1.我们发现v8＞4，可知明文应该大于4位，有(Str[i] <= 96 || Str[i] > 122) && (Str[i] <= 64 || Str[i] > 90)可以推测明文为纯英文字母
2.strncpy函数是比较函数，我们发现strncmp(Str1,"23d4a52c56357cb705137656744dc055")为比较，密文为23d4a52c56357cb705137656744dc055，则看出摘要长度128bit，则排出sha256，推测md5
3.md5_calc(Str1, Destination, 4u)中，分别进行了malloc、md5_update、md5_init、md5_transform、data_round、并且四次shift转化，这可以看出来是md5加密，爆破即可。
4.爆出明文：BUPT
输入长度大于4，就在后面随便补一个小写字母即可

	输入字符串长度大于等于5
	取前四位进行加密，其输出结果为128bits，猜测该过程可能为哈希函数
	通过输出结果的长度判断，可能为MD5函数或者SHA-1函数
	观察sub_401420处函数，发现四个变量的初始化
	可以发现4个变量的取值，与MD5中ABCD四个初始变量一致，推测该函数为MD5函数
	通过暴力破解，求得flag
（笼统格式）


# 解题思路:#1.初步判断flag每个字符的ascii码值都在97~122之间，而且长度大于5
#2.满足以上条件，进入if判断后，先将输入Source的前四位复制给了Destination，# 然后执行了sub 401014函数，最后进行比较，若str1与字符串"b5c0b187fe309afaf4d35982fd961d7e'#完全相同，则输出"correct!”。
#3.根据最后的字符串初步判断是哈希加密，接下来我们看看sub 401014函数
# 4.进入sub 401014函数后，
#先执行了sub 401046函数，根据语句判断，这个函数的作用可能是数据填充，# v4[size]= 0x80，即字符串10000000,即先将比特“1”添加到消息的尾部，再添加k个零#而后size +56- size % 0x40，56字节，即448比特，而0x40，即64字节，即512比特，#因此对填充后的数据取模等于448比特，最后加上8字节，即64比特，使得整个明恰好为512的整数倍
#5.接着看看sub 401050函数，它将16个长度为1个字节的变量分别赋值给了4个变量，分别设为A,B,C，D，#使用快捷键H，将数值都调整为16进制，因为计算机为小端存储模式，因此可以观察到A,B,C,D真正的数值为:# A=0x67452301,B=0XEFCDAB89,C=0x98BADCFE,D=0x10325476
#6.完成赋值操作后，进入for循环，循环次数为sub 401046函数的返回值右移6位，即除以64，#然后进入sub 40108F函数进行简单的复制，然后进入sub 401037函数，发现对我们前面设置的A,B,C,D四个变量进行了64# 轮的轮函数，每16轮调用一个函数，经过64轮的轮函数后，变量A~D分别与初始值相加，函数返回
#7.因此通过分析，无论是数据填充还是轮函数，都符合MD5算法
#8.最后求出flag的前四位为“love”，因为flag长度为5位，于是在“love”后面随便加一个小写字母就好了